<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
<title type="text">Life is a Struggle</title>
<generator uri="https://github.com/mojombo/jekyll">Jekyll</generator>
<link rel="self" type="application/atom+xml" href="/feed.xml" />
<link rel="alternate" type="text/html" href="" />
<updated>2016-06-24T14:00:39+08:00</updated>
<id>/</id>
<author>
  <name>陆 伟</name>
  <uri>/</uri>
  <email>1071932819@qq.com</email>
</author>


<entry>
  <title type="html"><![CDATA[Android UDP服务]]></title>
 <link rel="alternate" type="text/html" href="/android/android-udp/" />
  <id>/android/android-udp</id>
  <published>2016-06-23T09:19:36+08:00</published>
  <updated>2016-06-23T09:19:36+08:00</updated>
  <author>
    <name>陆 伟</name>
    <uri></uri>
    <email>1071932819@qq.com</email>
  </author>
  <content type="html">
    

    &lt;p&gt;&lt;a href=&quot;/android/android-udp/&quot;&gt;Android UDP服务&lt;/a&gt; was originally published by 陆 伟 at &lt;a href=&quot;&quot;&gt;Life is a Struggle&lt;/a&gt; on June 23, 2016.&lt;/p&gt;
  </content>
</entry>


<entry>
  <title type="html"><![CDATA[学习YYModel]]></title>
 <link rel="alternate" type="text/html" href="/ios/record/yymodel/" />
  <id>/ios/record/yymodel</id>
  <published>2015-11-05T14:43:14+08:00</published>
  <updated>2015-11-05T14:43:14+08:00</updated>
  <author>
    <name>陆 伟</name>
    <uri></uri>
    <email>1071932819@qq.com</email>
  </author>
  <content type="html">
    &lt;h3 id=&quot;section&quot;&gt;序列化和反序列化&lt;/h3&gt;
&lt;p&gt;相信很多人都用过类的序列化和反序列化，在Android里面有Gson等第三方库可以做到，在IOS里面有setValuesForKeysWithDictionary这个方法。但是setValuesForKeysWithDictionary这个方法只能设置键值对，
遇到复杂的例如Iva对象就没办法处理了。我们都知道一个实体类里面包含的数据有两类：方法和属性，其中属性又分为基本类型、容器类型和实体(对象)类型。C++里面的基本类型
就那么几种：int、float、byte等。在IOS里面如果一个实体类只包含这些基本类型，那就可以通过- (void)setValuesForKeysWithDictionary:(NSDictionary&amp;amp;ltNSString *, id&amp;gt; *)keyedValues;
直接将一个从json字符串中提取出来的字典转为实体类，当然你必须实现-(void)setValue:(id)value forUndefinedKey:(NSString *)key方法，以防服务器返回的字段跟你实体类定义的名字不一样。&lt;/p&gt;

&lt;h3 id=&quot;ios&quot;&gt;IOS中如何处理一般实体类的序列化&lt;/h3&gt;
&lt;p&gt;前面我们说Android里面有很多第三方库可以做到，IOS也是如此：&lt;a href=&quot;https://github.com/Mantle/Mantle&quot;&gt;Mantle&lt;/a&gt;、&lt;a href=&quot;https://github.com/icanzilb/JSONModel&quot;&gt;JSONModel&lt;/a&gt;、
&lt;a href=&quot;https://github.com/Yalantis/FastEasyMapping&quot;&gt;FastEasyMapping&lt;/a&gt;、&lt;a href=&quot;https://github.com/CoderMJLee/MJExtension&quot;&gt;MJExtension&lt;/a&gt;、&lt;a href=&quot;https://github.com/ibireme/YYKit&quot;&gt;YYModel&lt;/a&gt;
等等。其中我选取了YYModel作为学习对象，因为这个库文件最少最简单，而且根据他自己的介绍来看，貌似效率挺不错。&lt;/p&gt;

&lt;h3 id=&quot;id&quot;&gt;什么是id&lt;/h3&gt;
&lt;p&gt;要对一个类序列化首先需要知道IOS里面对象的结构。我们知道C里面是没有类的，只有结构体。C++在C的结构体基础上提出了类的概念和结构，OC也是如此，
OC的类就是结构体。在OC里面的对象都可以使用id类型来表示，A *a也可以写成 id a。那么id是什么呢，id在objc.h中定义如下：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
//A pointer to an instance of a class.
typedef struct objc_object *id;
&lt;/pre&gt;
&lt;p&gt;就像注释中所说的这样id是指向一个objc_object结构体的指针。objc_object在objc.h中的定义：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
//Represents an instance of a class.
struct objc_object
{
    Class isa;
}
&lt;/pre&gt;
&lt;p&gt;这个时候我们知道OBjective-C中的object在最后会被转换成C的结构体，而在这个struct中有一个isa指针，指向它的类别Class(C是大写的):&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
//Represents an instance of a class.
//An opaque type that represents an Objective-C class
typedef struct objc_class *Class;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，Class本身也是指向一个C的structobjc_class:&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
struct objc_class
{
    Class isa OBJC_ISA_AVAILABILITY;

    Class super_class;
    const char *name;
    long version;
    long info;
    long instance_size;
    struct objc_ivar_list *ivars;
    struct objc_method_list **methodLists;
    struct objc_cache *cache;
    struct objc_protocol_list *protocols; 
};
&lt;/pre&gt;
&lt;p&gt;该结构中，isa指向所属的Class,super_class指向父类别。在objc_runtime_new.h中，我们发现objc_class有如下定义：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
struct object_class : objc_object
{
    //Class ISA
    Class superclass;

    ...
    ...
}
&lt;/pre&gt;

&lt;h3 id=&quot;meta-class&quot;&gt;什么是Meta Class&lt;/h3&gt;
&lt;p&gt;根据上面的描述，我们可以把Meta Class理解为一个Class对象的class。简单的说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当我们发送一个消息给一个NSObject对象时，这条消息会在对象类的方法列表里查找。&lt;/li&gt;
&lt;li&gt;当我们发送一个消息给一个类时，这条消息会在类的Meta Class的方法列表中查找。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而Meta Class也是一个Class，它跟其他Class一样有自己的isa和super_class指针。
具体的如图所示：&lt;/p&gt;
&lt;figure&gt;
	&lt;img src=&quot;/images/IOS/record/yymodel/object_struct.jpeg&quot; /&gt; 
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;每个Class都有一个isa指针指向一个唯一的Meta Class&lt;/li&gt;
&lt;li&gt;每一个Meta Class的isa指针都指向嘴上层的Meta Class&lt;/li&gt;
&lt;li&gt;最上层的Meta Class的super class指向自己，形成一个环路&lt;/li&gt;
&lt;li&gt;每一个Meta Class的super class指针指向它原本Class的 Super Class的Meta Class。但是最上层的Meta Class的 Super Class指向NSObject Class本身&lt;/li&gt;
&lt;li&gt;最上层的NSObject Class的super Class指向nil。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;yymodel&quot;&gt;华丽丽的分割线 其实上面说的根本没有卵用 我们来看看YYModel的序列化过程&lt;/h3&gt;
&lt;p&gt;序列化的步骤一般都是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遍历类定义中的所有属性，储存在一个字典中。&lt;/li&gt;
&lt;li&gt;找到所有属性对应的set和get方法，储存在一个字典里&lt;/li&gt; 
&lt;li&gt;确认json字典里的key和类定义中属性的映射关系，一般来说json字典里的key的名字就是我们类定义中的属性名，所以如果不需要定制化，这一步是可以省略的&lt;/li&gt; 
&lt;li&gt;解析需要序列化的字典，根据key和value的类型判断
    需要序列化的对象类型&lt;/li&gt;
&lt;li&gt;根据该对象类型的属性和方法字典来实例化一个对象，并设置好值，这个就是我们要得结果了&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;YYModel的序列化过程也是这样，首先有一个YYClassInfo对象来储存class信息：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
+ (instancetype)classInfoWithClass:(Class)cls {
    if (!cls) return nil;
    static CFMutableDictionaryRef classCache;
    static CFMutableDictionaryRef metaCache;
    static dispatch_once_t onceToken;
    static OSSpinLock lock;
    dispatch_once(&amp;amp;onceToken, ^{
        classCache = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;amp;kCFTypeDictionaryKeyCallBacks, &amp;amp;kCFTypeDictionaryValueCallBacks);
        metaCache = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;amp;kCFTypeDictionaryKeyCallBacks, &amp;amp;kCFTypeDictionaryValueCallBacks);
        lock = OS_SPINLOCK_INIT;
    });
    OSSpinLockLock(&amp;amp;lock);
    YYClassInfo *info = CFDictionaryGetValue(class_isMetaClass(cls) ? metaCache : classCache, (__bridge const void *)(cls));
    if (info &amp;amp;&amp;amp; info-&amp;gt;_needUpdate) {
        [info _update];
    }
    OSSpinLockUnlock(&amp;amp;lock);
    if (!info) {
        info = [[YYClassInfo alloc] initWithClass:cls];
        if (info) {
            OSSpinLockLock(&amp;amp;lock);
            CFDictionarySetValue(info.isMeta ? metaCache : classCache, (__bridge const void *)(cls), (__bridge const void *)(info));
            OSSpinLockUnlock(&amp;amp;lock);
        }
    }
    return info;
}
&lt;/pre&gt;
&lt;p&gt;可以看到所有出现的class定义都会储存在一个全局静态字典classCache和metaCache中。我们再看一个YYClassInfo包含那些数据呢：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
/**
 Class information for a class.
 */
@interface YYClassInfo : NSObject
@property (nonatomic, assign, readonly) Class cls;
@property (nonatomic, strong, readonly) Class superCls;
@property (nonatomic, assign, readonly) Class metaCls;
@property (nonatomic, assign, readonly) BOOL isMeta;
@property (nonatomic, strong, readonly) NSString *name;
@property (nonatomic, strong, readonly) YYClassInfo *superClassInfo;
@property (nonatomic, strong, readonly) NSDictionary *ivarInfos;     //&amp;amp;lt key:NSString(ivar),     value:YYClassIvarInfo
@property (nonatomic, strong, readonly) NSDictionary *methodInfos;   //&amp;amp;lt key:NSString(selector), value:YYClassMethodInfo
@property (nonatomic, strong, readonly) NSDictionary *propertyInfos; //&amp;amp;lt key:NSString(property), value:YYClassPropertyInfo
@end
/**
 Instance variable information.
 */
@interface YYClassIvarInfo : NSObject
@property (nonatomic, assign, readonly) Ivar ivar;
@property (nonatomic, strong, readonly) NSString *name; //&amp;amp;lt Ivar&#39;s name
@property (nonatomic, assign, readonly) ptrdiff_t offset; //&amp;amp;lt Ivar&#39;s offset
@property (nonatomic, strong, readonly) NSString *typeEncoding; //&amp;amp;lt Ivar&#39;s type encoding
@property (nonatomic, assign, readonly) YYEncodingType type; //&amp;amp;lt Ivar&#39;s type 
@end
/**
 Method information.
 */
@interface YYClassMethodInfo : NSObject
@property (nonatomic, assign, readonly) Method method;
@property (nonatomic, strong, readonly) NSString *name; //&amp;amp;lt method name
@property (nonatomic, assign, readonly) SEL sel; //&amp;amp;lt method&#39;s selector
@property (nonatomic, assign, readonly) IMP imp; //&amp;amp;lt method&#39;s implementation
@property (nonatomic, strong, readonly) NSString *typeEncoding; //&amp;amp;lt method&#39;s parameter and return types
@property (nonatomic, strong, readonly) NSString *returnTypeEncoding; //&amp;amp;lt return value&#39;s type
@property (nonatomic, strong, readonly) NSArray *argumentTypeEncodings; //&amp;amp;lt array of arguments&#39; type
@end
/**
 Property information.
 */
@interface YYClassPropertyInfo : NSObject
@property (nonatomic, assign, readonly) objc_property_t property;
@property (nonatomic, strong, readonly) NSString *name; //&amp;amp;lt property&#39;s name
@property (nonatomic, assign, readonly) YYEncodingType type; //&amp;amp;lt property&#39;s type
@property (nonatomic, strong, readonly) NSString *typeEncoding; //&amp;amp;lt property&#39;s encoding value
@property (nonatomic, strong, readonly) NSString *ivarName; //&amp;amp;lt property&#39;s ivar name
@property (nonatomic, assign, readonly) Class cls; //&amp;amp;lt may be nil
@property (nonatomic, strong, readonly) NSString *getter; //&amp;amp;lt getter (nonnull)
@property (nonatomic, strong, readonly) NSString *setter; //&amp;amp;lt setter (nonnull)
@end
&lt;/pre&gt;
&lt;p&gt;我只截取了属性定义的部分。YYClassInfo储存了一个类里面所有的属性和方法字典，并保存了_cls、_superCls和_metaCls的签名。
主要使用了OC的class_copyMethodList、class_copyPropertyList和class_copyIvarList方法，动过cls签名获取了类的信息。
当然，说起来好像很简单，实际需要你对OC的底层非常了解，知道objc_method、objc_ivar和objc_property的定义，知道Type Encodings和Declared Properties这些信息，才能真的解析出我们需要的信息。
这里我找到了OC里面关于上面那些结构体的定义：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
类的数据结构

Class(指针)

typedef struct objc_class *Class;
       
/*
  这是由编译器为每个类产生的数据结构,这个结构定义了一个类.这个结构是通过编译器在执行时产生,在运行时发送消息时使用.因此,一些成员改变了类型.编译器产生&quot;char* const&quot;类型的字符串指针替代了下面的成员变量&quot;super_class&quot;
*/
struct objc_class {
  struct objc_class*  class_pointer;    /* 指向元类的指针. */
  struct objc_class*  super_class;      /* 指向父类的指针. 对于NSObject来说是NULL.*/
  const char*         name;             /* 类的名称. */
  long                version;          /* 未知. */
  unsigned long       info;             /* 比特蒙板.  参考下面类的蒙板定义. */
  long                instance_size;    /* 类的字节数.包含类的定义和所有父类的定义 */
#ifdef _WIN64
  long pad;
#endif
  struct objc_ivar_list* ivars;         /* 指向类中定义的实例变量的列表结构. NULL代表没有实例变量.不包括父类的变量. */
  struct objc_method_list*  methods;    /* 链接类中定义的实例方法. */
  struct sarray *    dtable;            /* 指向实例方法分配表. */
  struct objc_class* subclass_list;     /* 父类列表 */
  struct objc_class* sibling_class;
  struct objc_protocol_list *protocols; /* 要实现的原型列表 */
  void* gc_object_type;
};
Method(指针)

typedef struct objc_method *Method;
       
/* 编译器依据类中定义的方法为该类产生一个或更多这种这种结构.
    一个类的实现可以分散在一个文件中不同部分,同时类别可以分散在不同的模块中.为了处理这个问题,使用一个单独的方法链表 */
struct objc_method
{
  SEL         method_name;  /* 这个变量就是方法的名称.编译器使用在这里使用一个`char*`,当一个方法被注册,名称在运行时被使用真正的SEL替代  */
  const char* method_types; /* 描述方法的参数列表. 在运行时注册选择器时使用.那时候方法名就会包含方法的参数列表.*/
  IMP         method_imp;   /* 方法执行时候的地址. */
};
Ivar(指针)

typedef struct objc_ivar *Ivar;
       
/* 编译器依据类中定义的实例变量为该类产生一个或更多这种这种结构  */
struct objc_ivar
{
  const char* ivar_name;  /* 类中定义的变量名. */
  const char* ivar_type;  /* 描述变量的类型.调试时非常有用. */
  int        ivar_offset; /* 实例结构的基地址偏移字节 */
};
Category(指针)

typedef struct objc_category *Category;
       
/* 编译器为每个类别产生一个这样的结构.一个类可以具有多个类别同时既包括实例方法,也可以包括类方法*/
struct objc_category
{
  const char*   category_name;                /* 类别名.定义在类别后面的括号内*/
  const char*   class_name;                   /* 类名 */
  struct objc_method_list  *instance_methods; /* 链接类中定义的实例方法. NULL表示没有实例方法. */
  struct objc_method_list *class_methods;     /* 链接类中定义的类方法. NULL表示没有类方法. */
  struct objc_protocol_list *protocols;       /* 遵循的协议表  */
};
objc_property_t

typedef struct objc_property *objc_property_t;
IMP

id (*IMP)(id, SEL, ...)
SEL

typedef struct objc_selector *SEL;
       
struct objc_selector
{
  void *sel_id;
  const char *sel_types;
};
objc_method_list

struct objc_method_list
{
  struct objc_method_list*  method_next; /* 这个变量用来链接另一个单独的方法链表 */
  int            method_count;            /* 结构中定义的方法数量 */
  struct objc_method method_list[1];      /* 可变长度的结构 */
};
objc_cache

struct objc_cache
{
    unsigned int mask;
    unsigned int occupied;
    Method buckets[1];
};
objc_protocol_list

struct objc_protocol_list
{
  struct objc_protocol_list *next;
  size_t count;
  struct objc_protocol *list[1];
};
实例的数据结构

id

typedef struct objc_object *id;
objc_object

struct objc_object
{
  /* 类的指针是对象相关的类.如果是一个类对象, 这个指针指向元类.
  Class isa;
};
objc_super

struct objc_super
{
  id    self;        /* 消息的接受者  */
  Class super_class; /* 接受者的父类  */
};

&lt;/pre&gt;
&lt;p&gt;有了上面这些信息相信所有人都知道作者的代码都在干嘛了，具体不表。反正到此为止，我们已经有了class的定义。
理论上下一步就可以解析了，但是作者额外多了一步，定制了映射关系。出现了一个新的class属性映射关系类的定义：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
//A class info in object model.
@interface _YYModelMeta : NSObject {
@public
    // Key:mapped key and key path, Value:_YYModelPropertyInfo.
    NSDictionary *_mapper;
    // Array&amp;lt;_YYModelPropertyInfo&amp;gt;, all property meta of this model.
    NSArray *_allPropertyMetas;
    // Array&amp;lt;_YYModelPropertyInfo&amp;gt;, property meta which is mapped to a key path.
    NSArray *_keyPathPropertyMetas;
    // The number of mapped key (and key path), same to _mapper.count.
    NSUInteger _keyMappedCount;
    // Model class type.
    YYEncodingNSType _nsType;
    
    BOOL _hasCustomTransformFromDictonary;
    BOOL _hasCustomTransformToDictionary;
}
@end
&lt;/pre&gt;
&lt;p&gt;上面的YYClassInfo更像是一个抽象的模板，只是告诉我们类里面有这些属性和方法，没有告诉我们怎么去解析。_YYModelMeta这个类就是告诉我们怎么去解析的。
同样的所有_YYModelMeta都缓存在了一个全局静态字典里面。_YYModelMeta通过YYClassInfo的信息来实例化：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
- (instancetype)initWithClass:(Class)cls {
    YYClassInfo *classInfo = [YYClassInfo classInfoWithClass:cls];
    if (!classInfo) return nil;
    self = [super init];
    
    // Get black list
    NSSet *blacklist = nil;
    if ([cls respondsToSelector:@selector(modelPropertyBlacklist)]) {
        NSArray *properties = [(id&amp;amp;ltYYModel&amp;gt;)cls modelPropertyBlacklist];
        if (properties) {
            blacklist = [NSSet setWithArray:properties];
        }
    }
    
    // Get white list
    NSSet *whitelist = nil;
    if ([cls respondsToSelector:@selector(modelPropertyWhitelist)]) {
        NSArray *properties = [(id&amp;amp;ltYYModel&amp;gt;)cls modelPropertyWhitelist];
        if (properties) {
            whitelist = [NSSet setWithArray:properties];
        }
    }
    
    // Get container property&#39;s generic class
    NSDictionary *genericMapper = nil;
    if ([cls respondsToSelector:@selector(modelContainerPropertyGenericClass)]) {
        genericMapper = [(id&amp;amp;ltYYModel&amp;gt;)cls modelContainerPropertyGenericClass];
        if (genericMapper) {
            NSMutableDictionary *tmp = genericMapper.mutableCopy;
            [genericMapper enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
                if (![key isKindOfClass:[NSString class]]) return;
                Class meta = object_getClass(obj);
                if (!meta) return;
                if (class_isMetaClass(meta)) {
                    tmp[key] = obj;
                } else if ([obj isKindOfClass:[NSString class]]) {
                    Class cls = NSClassFromString(obj);
                    if (cls) {
                        tmp[key] = cls;
                    }
                }
            }];
            genericMapper = tmp;
        }
    }
    
    // Create all property metas.
    NSMutableDictionary *allPropertyMetas = [NSMutableDictionary new];
    YYClassInfo *curClassInfo = classInfo;
    while (curClassInfo &amp;amp;&amp;amp; curClassInfo.superCls != nil) { // recursive parse super class, but ignore root class (NSObject/NSProxy)
        for (YYClassPropertyInfo *propertyInfo in curClassInfo.propertyInfos.allValues) {
            if (!propertyInfo.name) continue;
            if (blacklist &amp;amp;&amp;amp; [blacklist containsObject:propertyInfo.name]) continue;
            if (whitelist &amp;amp;&amp;amp; ![whitelist containsObject:propertyInfo.name]) continue;
            _YYModelPropertyMeta *meta = [_YYModelPropertyMeta metaWithClassInfo:classInfo
                                                                    propertyInfo:propertyInfo
                                                                         generic:genericMapper[propertyInfo.name]];
            if (!meta || !meta-&amp;gt;_name) continue;
            if (!meta-&amp;gt;_getter &amp;amp;&amp;amp; !meta-&amp;gt;_setter) continue;
            if (allPropertyMetas[meta-&amp;gt;_name]) continue;
            allPropertyMetas[meta-&amp;gt;_name] = meta;
        }
        curClassInfo = curClassInfo.superClassInfo;
    }
    if (allPropertyMetas.count) _allPropertyMetas = allPropertyMetas.allValues.copy;
    
    // create mapper
    NSMutableDictionary *mapper = [NSMutableDictionary new];
    NSMutableArray *keyPathPropertyMetas = [NSMutableArray new];
    if ([cls respondsToSelector:@selector(modelCustomPropertyMapper)]) {
        NSDictionary *customMapper = [(id &amp;amp;ltYYModel&amp;gt;)cls modelCustomPropertyMapper];
        [customMapper enumerateKeysAndObjectsUsingBlock:^(NSString *propertyName, NSString *mappedToKey, BOOL *stop) {
            _YYModelPropertyMeta *propertyMeta = allPropertyMetas[propertyName];
            if (propertyMeta) {
                NSArray *keyPath = [mappedToKey componentsSeparatedByString:@&quot;.&quot;];
                propertyMeta-&amp;gt;_mappedToKey = mappedToKey;
                if (keyPath.count &amp;gt; 1) {
                    propertyMeta-&amp;gt;_mappedToKeyPath = keyPath;
                    [keyPathPropertyMetas addObject:propertyMeta];
                }
                [allPropertyMetas removeObjectForKey:propertyName];
                if (mapper[mappedToKey]) {
                    ((_YYModelPropertyMeta *)mapper[mappedToKey])-&amp;gt;_next = propertyMeta;
                } else {
                    mapper[mappedToKey] = propertyMeta;
                }
            }
        }];
    }
    [allPropertyMetas enumerateKeysAndObjectsUsingBlock:^(NSString *name, _YYModelPropertyMeta *propertyMeta, BOOL *stop) {
        propertyMeta-&amp;gt;_mappedToKey = name;
        if (mapper[name]) {
            ((_YYModelPropertyMeta *)mapper[name])-&amp;gt;_next = propertyMeta;
        } else {
            mapper[name] = propertyMeta;
        }
    }];
    
    if (mapper.count) _mapper = mapper;
    if(keyPathPropertyMetas) _keyPathPropertyMetas = keyPathPropertyMetas;
    _keyMappedCount = _allPropertyMetas.count;
    _nsType = YYClassGetNSType(cls);
    _hasCustomTransformFromDictonary = ([cls instancesRespondToSelector:@selector(modelCustomTransformFromDictionary:)]);
    _hasCustomTransformToDictionary = ([cls instancesRespondToSelector:@selector(modelCustomTransformToDictionary:)]);
    
    return self;
}
&lt;/pre&gt;
&lt;p&gt;翻译成伪代码就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.获取属性的白名单、黑名单和解析的key-value映射表。&lt;/li&gt;
&lt;li&gt;2.根据这些信息生成Json字典里的key和类定义中的映射关系，保存在一个map中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;白名单的作用就是如果存在白名单则在实例化的时候只管白名单里面的属性，_YYModelMeta里面也只保存白名单里面的属性映射。黑名单的作用就是过滤掉黑名单里面的属性，其他的属性映射都保存。
当然一般简单地序列化是不需要这些个定制化的东西的，作者还额外实现了一些特殊属性的特殊映射关系，比如一些类定义里面的字典或者数组该如何实例化，我们就需要知道这些数组和字典里面储存的是
什么类型的value，作者通过modelContainerPropertyGenericClass这个接口，让用户自己来设置。作者还额外提供了一个接口modelCustomPropertyMapper，顾名思义，某些属性的名字跟
json字典中的key不一样或者本身就需要映射到跟属性不同名的key上，用户就可以通过这个接口返回一个字典来设置：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
/**
 Custom property mapper.
 
 @discussion If the key in JSON/Dictionary does not match to the model&#39;s property name,
 implements this method and returns the additional mapper.
 
 Example:
    
    json: 
        {
            &quot;n&quot;:&quot;Harry Pottery&quot;,
            &quot;p&quot;: 256,
            &quot;ext&quot; : {
                &quot;desc&quot; : &quot;A book written by J.K.Rowing.&quot;
            }
        }
 
    model:
        @interface YYBook : NSObject
        @property NSString *name;
        @property NSInteger page;
        @property NSString *desc;
        @end
 
        @implementation YYBook
        + (NSDictionary *)modelCustomPropertyMapper {
            return @{@&quot;name&quot; : @&quot;n&quot;,
                     @&quot;page&quot; : @&quot;p&quot;,
                     @&quot;desc&quot; : @&quot;ext.desc&quot;};
        }
        @end
 
 @return A custom mapper for properties.
 */
+ (NSDictionary *)modelCustomPropertyMapper;
&lt;/pre&gt;
&lt;p&gt;在生成映射表的时候有个问题，那就是一个key只能对应一个value，加入类A中的属性B、C都要对应到json字典中的KeyB字段，则这个映射表是没办法实现的，
这也是为什么作者在_YYModelPropertyMeta的定义中添加_YYModelPropertyMeta *_next;这个属性。_YYModelPropertyMeta的完整定义如下:&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
// A property info in object model.
@interface _YYModelPropertyMeta : NSObject {
@public
    NSString *_name;             //&amp;amp;lt property&#39;s name
    YYEncodingType _type;        //&amp;amp;lt property&#39;s type
    YYEncodingNSType _nsType;    //&amp;amp;lt property&#39;s Foundation type
    BOOL _isCNumber;             //&amp;amp;lt is c number type
    Class _cls;                  //&amp;amp;lt property&#39;s class, or nil
    Class _genericCls;           //&amp;amp;lt container&#39;s generic class, or nil if threr&#39;s no generic class
    SEL _getter;                 //&amp;amp;lt getter, or nil if the instances cannot respond
    SEL _setter;                 //&amp;amp;lt setter, or nil if the instances cannot respond
    
    NSString *_mappedToKey;      //&amp;amp;lt the key mapped to
    NSArray *_mappedToKeyPath;   //&amp;amp;lt the key path mapped to (nil if the name is not key path)
    _YYModelPropertyMeta *_next; //&amp;amp;lt next meta if there are multiple properties mapped to the same key.
}
@end
&lt;/pre&gt;
&lt;p&gt;我们已经知道了YYClassInfo和_YYModelMeta的关系，那么_YYModelPropertyMeta和YYClassPropertyInfo是什么关系呢？我们看到YYClassPropertyInfo中
保存的是属性的原始模板信息，而且代码里有一段：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
_YYModelPropertyMeta *meta = [_YYModelPropertyMeta metaWithClassInfo:classInfo
                                                                    propertyInfo:propertyInfo
                                                                         generic:genericMapper[propertyInfo.name]];
&lt;/pre&gt;
&lt;p&gt;可以看到_YYModelPropertyMeta是通过YYClassPropertyInfo模板生成的，_YYModelPropertyMeta里面保存的信息相对于YYClassPropertyInfo来说更少也更针对，
_YYModelPropertyMeta把YYClassPropertyInfo中的get和set方法名转化成了SEL类型的对象，我学OC时间不长，也不知道该怎么称呼SEL对象，叫方法选择器？Whatever。。。
习惯了C++的朋友直接理解成函数地址也行，习惯了Window的消息分发机制的也可以理解为接受消息的对象，反正得到这个之后想要设置属性的值就只需要调用OC的发送消息接口就行了，比如下面的代码：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
/**
 Set number to property.
 @discussion Caller should hold strong reference to the parameters before this function returns.
 @param model Should not be nil.
 @param num   Can be nil.
 @param meta  Should not be nil, meta.isCNumber should be YES, meta.setter should not be nil.
 */
static force_inline void ModelSetNumberToProperty(__unsafe_unretained id model,
                                                  __unsafe_unretained NSNumber *num,
                                                  __unsafe_unretained _YYModelPropertyMeta *meta) {
    switch (meta-&amp;gt;_type &amp;amp; YYEncodingTypeMask) {
        case YYEncodingTypeBool: {
            ((void (*)(id, SEL, bool))(void *) objc_msgSend)((id)model, meta-&amp;gt;_setter, num.boolValue);
        } break;
        case YYEncodingTypeInt8: {
            ((void (*)(id, SEL, int8_t))(void *) objc_msgSend)((id)model, meta-&amp;gt;_setter, (int8_t)num.charValue);
        } break;
        case YYEncodingTypeUInt8: {
            ((void (*)(id, SEL, uint8_t))(void *) objc_msgSend)((id)model, meta-&amp;gt;_setter, (uint8_t)num.unsignedCharValue);
        } break;
        case YYEncodingTypeInt16: {
            ((void (*)(id, SEL, int16_t))(void *) objc_msgSend)((id)model, meta-&amp;gt;_setter, (int16_t)num.shortValue);
        } break;
        case YYEncodingTypeUInt16: {
            ((void (*)(id, SEL, uint16_t))(void *) objc_msgSend)((id)model, meta-&amp;gt;_setter, (uint16_t)num.unsignedShortValue);
        } break;
        case YYEncodingTypeInt32: {
            ((void (*)(id, SEL, int32_t))(void *) objc_msgSend)((id)model, meta-&amp;gt;_setter, (int32_t)num.intValue);
        }
        case YYEncodingTypeUInt32: {
            ((void (*)(id, SEL, uint32_t))(void *) objc_msgSend)((id)model, meta-&amp;gt;_setter, (uint32_t)num.unsignedIntValue);
        } break;
        case YYEncodingTypeInt64: {
            ((void (*)(id, SEL, int64_t))(void *) objc_msgSend)((id)model, meta-&amp;gt;_setter, (int64_t)num.longLongValue);
        }
        case YYEncodingTypeUInt64: {
            ((void (*)(id, SEL, uint64_t))(void *) objc_msgSend)((id)model, meta-&amp;gt;_setter, (uint64_t)num.unsignedLongLongValue);
        } break;
        case YYEncodingTypeFloat: {
            float f = num.floatValue;
            if (isnan(f) || isinf(f)) f = 0;
            ((void (*)(id, SEL, float))(void *) objc_msgSend)((id)model, meta-&amp;gt;_setter, f);
        } break;
        case YYEncodingTypeDouble: {
            double d = num.floatValue;
            if (isnan(d) || isinf(d)) d = 0;
            ((void (*)(id, SEL, double))(void *) objc_msgSend)((id)model, meta-&amp;gt;_setter, d);
        } break;
        case YYEncodingTypeLongDouble: {
            double d = num.floatValue;
            if (isnan(d) || isinf(d)) d = 0;
            ((void (*)(id, SEL, long double))(void *) objc_msgSend)((id)model, meta-&amp;gt;_setter, (long double)d);
        } break;
        default: break;
    }
}
&lt;/pre&gt;
&lt;p&gt;当然_YYModelPropertyMeta跟YYClassPropertyInfo的关系也是一个我们解析时使用的映射表，一个只是属性模板。
到这里我不产生了疑问：YYClassIvarInfo和YYClassMethodInfo对应的映射表呢？YYClassMethodInfo不需要映射，因为他不是属性，不需要赋值，但是YYClassIvarInfo
就不一样了，他表示一个实例变量。但是我们看作者的代码里前前后后好像就没YYClassIvarInfo的事儿。什么才是实例变量呢？一个类里面的实例变量是什么呢？不是属性么？一大串问号。。。。。
我们都知道OC的定义可以像下面这么写：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
@interface A : NSObject{
    NSString *_name;
}
@property (nonatomic, strong) NSString *name;
@end
@implementation A
@synthesize name = _name;
@end
&lt;/pre&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
@interface A : NSObject{
    NSString *name;
}
@property (nonatomic, strong) NSString *name;
@implementation A
@synthesize name;
@end
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
@interface A : NSObject
@property (nonatomic, strong) NSString *name;
@implementation A
@synthesize name;
@end
&lt;/pre&gt;
&lt;p&gt;区别是什么呢？看知乎大神的回答：&lt;/p&gt;

&lt;p&gt;著作权归作者所有。
商业转载请联系作者获得授权，非商业转载请注明出处。
作者：RefuseBT
链接：http://www.zhihu.com/question/22195598/answer/39593235
来源：知乎&lt;/p&gt;

&lt;p&gt;对于方式1，定义最完备。继承时，子类直接访问父类成员变量无需再@synthesize。缺点就是麻烦，重构也麻烦。第二种的问题，在于成员变量没有下划线。这个修改的好处你可能一开始体会不到。其实加下划线最大的好处在于局部变量命名不会冲突。比如你一个成员变量叫name，你的入参也叫name，就会出现覆盖。这个时候简便的办法是对name加冠词，比如aName、anObj，看起来还是挺恶心的。虽然OC也这样干。这个时候如果声明为_name就一劳永逸了，况且编译器还能替你做了这个事。第三种的问题，也是第一种的优势，就是你在父类中可以直接访问成员变量，但是子类中你无法访问，只能通过属性访问到。如果属性还是在.m中声明的，麻烦更多。另外从命名上还兼有第二种的缺陷。那么最好的写法写法一：@interface Person : NSObject
{
}
@property (nonatomic, strong) NSString *name;
@end&lt;/p&gt;

&lt;p&gt;@implementation Person
@end
这个适用与一般情况，编译器自动生成成员变量_name，而且写法最简单，不必重复声明。写法二，针对继承情况下，向子类暴露父类成员变量：@interface Person : NSObject
{
	NSString *_name;
}
@property (nonatomic, strong) NSString *name;
@end&lt;/p&gt;

&lt;p&gt;@implementation Person
@synthesize name = _name;
@end
其实@synthesize那条你不写也行，不过我还是喜欢声明完备，毕竟同一个成员变量，两个地方声明。&lt;/p&gt;

&lt;p&gt;OK这下我们知道了其实我们上面说的属性和实例变量基本就是一个东西了。但是我们一个属性对象YYClassPropertyInfo只是包含了get和set方法的名字以及属性名等一些基本信息
YYClassIvarInfo里面最特殊的就是@property (nonatomic, assign, readonly) ptrdiff_t offset; //&amp;lt; Ivar’s offset这个属性了
学过C的都知道，所有数据的访问最后都是要转化为地址的，一个char[10]数组要访问第8个数据，就要知道第发布数据的地址，offset就相当于实例变量的地址索引。offset加上
首地址就得到了实例变量的地址。但是我不得不说作者把这些数据保存下来之后貌似并没有使用。。。。。。&lt;/p&gt;

&lt;p&gt;Anyway，我们已经得到了如何解析的映射表，愉快的进入了下一个步骤，解析Json数据。
作者在解析前加了很多道防线，防止用户传入的数据格式错误，不是一个字典或者jsonData类型的数据，这些这里就不表了。解析代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
- (BOOL)yy_modelSetWithDictionary:(NSDictionary *)dic {
    if (!dic || dic == (id)kCFNull) return NO;
    if (![dic isKindOfClass:[NSDictionary class]]) return NO;
    
    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)];
    if (modelMeta-&amp;gt;_keyMappedCount == 0) return NO;
    ModelSetContext context = {0};
    context.modelMeta = (__bridge void *)(modelMeta);
    context.model = (__bridge void *)(self);
    context.dictionary = (__bridge void *)(dic);
    
    if (modelMeta-&amp;gt;_keyMappedCount &amp;gt;= CFDictionaryGetCount((CFDictionaryRef)dic)) {
        CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &amp;amp;context);
        if (modelMeta-&amp;gt;_keyPathPropertyMetas) {
            CFArrayApplyFunction((CFArrayRef)modelMeta-&amp;gt;_keyPathPropertyMetas,
                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&amp;gt;_keyPathPropertyMetas)),
                                 ModelSetWithPropertyMetaArrayFunction,
                                 &amp;amp;context);
        }
    } else {
        CFArrayApplyFunction((CFArrayRef)modelMeta-&amp;gt;_allPropertyMetas,
                             CFRangeMake(0, modelMeta-&amp;gt;_keyMappedCount),
                             ModelSetWithPropertyMetaArrayFunction,
                             &amp;amp;context);
    }
    
    if (modelMeta-&amp;gt;_hasCustomTransformFromDictonary) {
        return [((id&amp;amp;ltYYModel&amp;gt;)self) modelCustomTransformFromDictionary:dic];
    }
    return YES;
}
&lt;/pre&gt;
&lt;p&gt;很简单，如果我们的映射表中的key超过了提供的json字典中的key的个数，我们就认为有些字段是不要设置值的，所以对json字典进行遍历，反之就对映射表进行遍历。
最后如果我们有一些自定义的转化规则，在最后调用用户自己写的modelCustomTransformFromDictionary方法。至此YYModel的解析就结束了&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;YYModel的作者真的是一个大神，我真心佩服这样的一个90后(同为90的我惭愧不已)，他写了很多开源的第三方库，而这些第三方库都是他在这两年内通公司项目总结等归纳出来的，
其中有很多很强大的YYText等控件（解决了文字竖排的问题，也是我下一个要学习的库）也得到了很多人的关注。其中YYModel只是这位大神利用业余时间2周写出来的随笔。。。。我
花了近1一个月时间才勉强弄懂了七八分，要让我自己写那是万万不能的。一个阶段的学习计划应该是先把YYModel再重新吃一边，直到吃透了，然后花两周时间默写出来。。。
然后在学习大神的YYText库，丰富我之前写的可怜的CoreText库（相比之下我这个简直不能叫库）。。。。。&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/ios/record/yymodel/&quot;&gt;学习YYModel&lt;/a&gt; was originally published by 陆 伟 at &lt;a href=&quot;&quot;&gt;Life is a Struggle&lt;/a&gt; on November 05, 2015.&lt;/p&gt;
  </content>
</entry>


<entry>
  <title type="html"><![CDATA[CoreTextView]]></title>
 <link rel="alternate" type="text/html" href="/ios/customview/coretextview/" />
  <id>/ios/customview/coretextview</id>
  <published>2015-11-04T11:39:43+08:00</published>
  <updated>2015-11-04T11:39:43+08:00</updated>
  <author>
    <name>陆 伟</name>
    <uri></uri>
    <email>1071932819@qq.com</email>
  </author>
  <content type="html">
    &lt;h3 id=&quot;section&quot;&gt;如何实现一个轻量级的竖排文字显示控件&lt;/h3&gt;
&lt;figure&gt;
	&lt;img src=&quot;/images/IOS/CustomView/releaseV1.1.png&quot; alt=&quot;项目实例&quot; /&gt;
	&lt;figcaption&gt;&lt;a href=&quot;https://github.com/luwei2012/CoreTextView&quot;&gt;CoreTextView&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;感谢&lt;a href=&quot;http://geeklu.com/2013/03/core-text/&quot;&gt;卢克&lt;/a&gt;的博客和代码，给了我很多帮助和启发。卢克的博客里详细介绍了如何使用Core Text来绘制富文本，
而且展示了苹果如何处理字体的分解图，加上&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/StringsTextFonts/Conceptual/CoreText_Programming/LayoutOperations/LayoutOperations.html&quot;&gt;苹果官方的demo&lt;/a&gt;,
最终我拼凑出来一个竖排显示文字的控件。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;竖排显示文字的核心思想&lt;/h3&gt;
&lt;p&gt;说起来很简单，可能大家也都看到过，其实在IOS的富文本属性中有两个不常用的属性：NSWritingDirectionAttributeName和NSVerticalGlyphFormAttributeName。
故名思议NSVerticalGlyphFormAttributeName就是控制文字竖向还是横向绘制，而NSWritingDirectionAttributeName控制的是文本绘制方向。
下面就很简单了，只需要把NSVerticalGlyphFormAttributeName设置为1(0 means horizontal text.  1 indicates vertical text.),NSWritingDirectionAttributeName设置为
@[@(NSWritingDirectionRightToLeft)]，理论上就能实现一个古文风格的竖排显示效果了。&lt;/p&gt;

&lt;p&gt;于是我满心欢喜的构建了一个富文本对象，并添加了这两个属性，然后发现并没有任何卵用。首先是NSVerticalGlyphFormAttributeName只针对英文起作用，其次NSVerticalGlyphFormAttributeName并没有改变绘制的方向。
这里我需要拎清楚两个概念：我在上面说NSWritingDirectionAttributeName控制的是文本绘制方向意思是文本从左到右绘制或者从右到左，这个我称之为文本绘制方向；我说NSVerticalGlyphFormAttributeName并没有改变绘制的方向
意思是把文字渲染到屏幕的方向。&lt;/p&gt;

&lt;p&gt;在我设置了NSVerticalGlyphFormAttributeName之后，文本里面的字母顺时针旋转了90°，变成了竖向显示，但是整个文本还是一行。也许有人就会想直接把控件旋转90°不就行了么，对于单行文本
这种做法确实是最简单有效地，但是需要绘制多行文本的时候，这个方法就很难控制了。你需要创建多个UILabel并设置他们的坐标、宽高等等，还需要自己切分文本，分段显示。。。听起来就觉得不可能实现。。&lt;/p&gt;

&lt;p&gt;偶然的机会，我在stackoverflow上看到一个提问，贴了一段代码，居然能实现了文本行变列，他提的问题是如何能使汉字和英文字符高度整体居中对齐。这种感觉就像是我还在解决温饱问题
而人家开始像怎么找乐子了。。。于是我那段代码扒了下来仔细研究了下。最核心的部分分为两个：&lt;/p&gt;

&lt;p&gt;1.创建CTFrameRef的时候需要添加一个属性kCTFrameProgressionAttributeName&lt;/p&gt;

&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
/*!
	@const		kCTFrameProgressionAttributeName
	@abstract	Specifies progression for a frame.
	
	@discussion Value must be a CFNumberRef containing a CTFrameProgression.
				Default is kCTFrameProgressionTopToBottom. This value determines
				the line stacking behavior for a frame and does not affect the
				appearance of the glyphs within that frame.

	@seealso	CTFramesetterCreateFrame
*/
CTFrameRef frame = CTFramesetterCreateFrame(framesetter,
                                            CFRangeMake(0, 0),
                                            path,
                                            (CFDictionaryRef)@{(id)kCTFrameProgressionAttributeName: @(kCTFrameProgressionRightToLeft)});
&lt;/pre&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
/*!
    @enum		CTFrameProgression
    @abstract	These constants specify frame progression types.

    @discussion The lines of text within a frame may be stacked for either
                horizontal or vertical text. Values are enumerated for each
                stacking type supported by CTFrame. Frames created with a
                progression type specifying vertical text will rotate lines
                90 degrees counterclockwise when drawing.

    @constant	kCTFrameProgressionTopToBottom
                Lines are stacked top to bottom for horizontal text.

    @constant	kCTFrameProgressionRightToLeft
                Lines are stacked right to left for vertical text.

    @constant	kCTFrameProgressionLeftToRight
                Lines are stacked left to right for vertical text.
*/

typedef CF_ENUM(uint32_t, CTFrameProgression) {
    kCTFrameProgressionTopToBottom  = 0,
    kCTFrameProgressionRightToLeft  = 1,
    kCTFrameProgressionLeftToRight  = 2
}
&lt;/pre&gt;
&lt;p&gt;至此我们就能控制文本的行变列。&lt;/p&gt;

&lt;p&gt;2.让汉字保持竖向&lt;/p&gt;

&lt;p&gt;添加了kCTFrameProgressionAttributeName属性后其实就相当于把绘制区域顺时针旋转了90°，汉字躺下了。。。因此我们需要为每个汉字额外设置一些样式：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
/*!
    @const      kCTVerticalFormsAttributeName
    @abstract   Controls glyph orientation.

    @discussion Value must be a CFBooleanRef. Default is false. A value of false
                indicates that horizontal glyph forms are to be used, true
                indicates that vertical glyph forms are to be used.
*/

extern const CFStringRef kCTVerticalFormsAttributeName CT_AVAILABLE(10_5, 4_3);
NSMutableAttributedString *attrStr = [[NSMutableAttributedString alloc] initWithString:self.text attributes:nil];

for (int i = 0; i &amp;lt; attrStr.length; i++) {
    if ([self isChinese:self.text index:i]) {
        [attrStr addAttribute:(id)kCTVerticalFormsAttributeName
                        value:@YES
                        range:NSMakeRange(i, 1)]; 
    }
}
&lt;/pre&gt;

&lt;p&gt;这两步处理完之后我们的文本就能够竖向显示了，只是字母跟汉字不会右对齐。但是到这里我们才刚开始。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;如何才能让文本居中显示？&lt;/h3&gt;
&lt;p&gt;使用Core Text绘制文本主要有&lt;/p&gt;

&lt;p&gt;1.获取画布并设置好坐标系&lt;/p&gt;

&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
//获取画布句柄
CGContextRef context = UIGraphicsGetCurrentContext();
//颠倒窗口 坐标计算使用的mac下的坐标系 跟ios的坐标系正好颠倒
CGContextSetTextMatrix(context, CGAffineTransformIdentity);
CGContextTranslateCTM(context, 0, self.bounds.size.height);
CGContextScaleCTM(context, 1.0, -1.0);
&lt;/pre&gt;

&lt;p&gt;2.生成需要绘制的内容&lt;/p&gt;

&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
//生成富文本的信息 具体不懂  反正这是core text绘制的必须流程和对象
CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((__bridge CFAttributedStringRef)self.attributedText);
&lt;/pre&gt;
&lt;p&gt;这里的attributedText就是一个富文本对象，我们可以设置行间距、字间距、颜色和字体等等一系列属性。&lt;/p&gt;

&lt;p&gt;3.生成绘制区域&lt;/p&gt;

&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
//这一步生成合适的绘制区域
CGPathRef path = [self createPathWithLines];
&lt;/pre&gt;
&lt;p&gt;createPathWithLines方法我们后面要讲，最简单的实现就是把整个self.bound作为绘制区域，就跟卢克的博客里写的一样&lt;/p&gt;

&lt;p&gt;4.绘制&lt;/p&gt;

&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
// Create a frame for this column and draw it.
CTFrameRef frame = CTFramesetterCreateFrame(framesetter,
                                            CFRangeMake(0, 0),
                                            path,
                                            (CFDictionaryRef)@{(id)kCTFrameProgressionAttributeName: @(kCTFrameProgressionRightToLeft)});
CTFrameDraw(frame, context);
&lt;/pre&gt;

&lt;p&gt;5.释放内存&lt;/p&gt;

&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
//释放内存
CFRelease(frame);
CFRelease(path);
CFRelease(framesetter);
&lt;/pre&gt;

&lt;p&gt;由此可见想要实现居中显示，我们只需要计算出正确的绘制区域就行了。其实不光是居中，你想要啥对齐效果都可以通过设置绘制区域来达到。
计算绘制区域的方法可以参见&lt;a href=&quot;https://github.com/luwei2012/CoreTextView&quot;&gt;我的代码&lt;/a&gt;都有详细的注释。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;处理横竖屏切换&lt;/h3&gt;
&lt;p&gt;这个很简单，横竖屏切换会触发layoutSubviews方法，在layoutSubviews方法里重绘即可。&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/ios/customview/coretextview/&quot;&gt;CoreTextView&lt;/a&gt; was originally published by 陆 伟 at &lt;a href=&quot;&quot;&gt;Life is a Struggle&lt;/a&gt; on November 04, 2015.&lt;/p&gt;
  </content>
</entry>


<entry>
  <title type="html"><![CDATA[关于ScrollView的学习]]></title>
 <link rel="alternate" type="text/html" href="/ios/record/scrollview/" />
  <id>/ios/record/scrollview</id>
  <published>2015-10-22T17:10:07+08:00</published>
  <updated>2015-10-22T17:10:07+08:00</updated>
  <author>
    <name>陆 伟</name>
    <uri></uri>
    <email>1071932819@qq.com</email>
  </author>
  <content type="html">
    &lt;h3 id=&quot;section&quot;&gt;写在前面的话&lt;/h3&gt;
&lt;p&gt;ScrollView应该是ios里面最常用的控件之一了，前两天在项目&lt;a href=&quot;https://www.9panart.com/html/passport/passport_login.html?ran=19406317709945142&quot;&gt;泛艺术App&lt;/a&gt;里面寻找一个UI的解决方案的时候曾经想过使用ScrollView，虽然最后使用的是它的儿子TableView，中间还是在ScrollView上吃了点苦头，
于是才决定写个demo好好研究下ScrollView。&lt;/p&gt;

&lt;h3 id=&quot;scrollview&quot;&gt;ScrollView的探究过程&lt;/h3&gt;
&lt;p&gt;ScrollView的特性相信大家都知道，有几个非常重要的属性：frame，contentSize，contentOffset，contentInset
    &amp;lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&amp;gt;
    -(UIScrollView *)scrollView{
        if (_scrollView == nil) {
            _scrollView                 = [[UIScrollView alloc] init];
            _scrollView.delegate        = self;
            _scrollView.scrollEnabled   = true;
            _scrollView.bounces         = true;
            _scrollView.showsHorizontalScrollIndicator  = false;
            _scrollView.showsVerticalScrollIndicator    = true;
            _scrollView.userInteractionEnabled          = YES;
            _scrollView.backgroundColor                 = [UIColor blueColor];
            _scrollView.contentInset                    = UIEdgeInsetsMake(100, 100, 100, 0);
            [self.view addSubview:_scrollView];
            [_scrollView mas_makeConstraints:^(MASConstraintMaker *make) {
                make.left.equalTo(self.view.mas_left);
                make.top.equalTo(self.view.mas_top);
                make.right.equalTo(self.view.mas_right);
                make.bottom.equalTo(self.view.mas_bottom);
            }];&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    }

    return _scrollView;
}
-(UIView *)containerView{
    if (_containerView == nil) {
        _containerView = [[UIView alloc] init];
        [self.scrollView addSubview:_containerView];
        [_containerView mas_makeConstraints:^(MASConstraintMaker *make) {
            make.left.equalTo(self.view.mas_left);
            make.top.equalTo(@(0));
            make.right.equalTo(self.view.mas_right);
            make.height.equalTo(@(SCREEN_HEIGHT * 2));
        }];
        self.scrollView.contentSize = CGSizeMake(SCREEN_WIDTH, SCREEN_HEIGHT * 2);
    }
    return _containerView;
}
-(void)viewDidAppear:(BOOL)animated{
    [super viewDidAppear:animated];
     NSLog(@&quot;%f %f&quot;,self.containerView.frame.origin.x,self.containerView.frame.origin.y);
}
&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
    contentInset:之所以首先说contentInset这个属性是因为我自己就被网上很多不负责任的言论坑过。contentInset只是contentSize的四个边增加了一块区域，仅此而已。
    网上有人说：“contentInset是scrollView的contentView的顶点相对于scrollView的位置，
    例如你的contentInset = (0 ,100)，那么你的contentView就是从scrollView的(0 ,100)开始显示”
    这句话完全就是在放P。contentInset不会对contentView产生任何影响.
    上面是我demo里面的一段代码，我使用了&lt;a href=&quot;https://github.com/SnapKit/Masonry&quot;&gt;Masonry这个库&lt;/a&gt;在代码里面设置约束，比IOS自带的接口方便好用几百倍。
    可以看到我在scrollView中添加了一个高度为两个屏幕高度的containerView，并且设置了contentSize和contentInset。结果打印出来的containerView的坐标是(0,0)。也就是说contentInset并不会
    影响containerView的位置，这个也很合理，因为我们并不想看到contentInset，必然不能把containerView的坐标给改了，否则程序一开始显示的就会是contentInset的内容了。
&lt;/li&gt;

&lt;li&gt;
    frame:也是一个让我迷惑的属性。从我上面的代码里可以看到，我并没有明确的设置frame，由此可以得出结论：frame可以通过scrollView的约束条件来设置，这无疑是一个好消息。
&lt;/li&gt;

&lt;li&gt;
    contentSize:这个属性就更加迷惑了。我在网上看到过一篇博客，是讲如何对scrollView使用autoLayout。博客里面的代码很简单，一个scrollView包含一个containerView，然后在containerView里面添加子View。
    然后问题就简化成只需要保证containerView跟scrollView的约束正确，containerView里面的内容布局跟普通的布局一样。
    &lt;a href=&quot;http://www.cocoachina.com/ios/20141011/9871.html&quot;&gt;原文说&lt;/a&gt;：&quot;我们知道scroll view除了自身的布局需要考虑（x, y, width, height）外，
    还有一个contentSize属性也必须要在布局的过程中进行确定，contentSize是UIScrollView用于确定它所 要展示的内容尺寸的大小，
    而这个contentSize在布局中实际上是又scroll view的子view :content view的宽和高实现的，注意：我们不能将content view的宽和高的约束设定为由scroll view决定
    （如和scroll view等宽、等高）,否则，Xcode会有警告：scroll view的content size不确定！在这种情况下，我们必须要对content view的布局约束引入scroll view之外其他参照物，
    我们拖进来一个辅助的view作为参照物or锚点。通过这个参考view，确定content view的宽度和高度，尽管content view的尺寸可以不依赖于scroll view，但我们还不得不设定content view 和其父view的关系：
    具体而言就是要确定content view和scroll view的top, bottom, leading和trailing contstraints，这个地方可能比较具有迷惑性，原因是苹果对于这四个约束的使用在scroll view中做了变化：
    它不再是确定content view尺寸的依据，而是帮助scroll view中content view四周的边界（or你可以理解为留白），进而确定scroll view的contentSize属性
    &quot;从这些话我推测如果是通过sb文件创建出来的scrollView会自动设置contentSize大小，问题是这个大小是怎么确定的，是不是就真的是scrollView里面所有内容的大小，还是scrollView的frame大小。
    通过我写的一个demo我得出了最终结论：scrollView的contentView是根据里面所有内容的大小设定的。

&lt;/li&gt;

&lt;li&gt;
    contentOffset:这个属性没杀好说的，决定了scrollView显示的内容的起始点。
&lt;/li&gt;

&lt;/ul&gt;

&lt;h3 id=&quot;scrollview-1&quot;&gt;ScrollView的额外问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
通过上面的探究过程可以知道我们可以直接在sb文件里面对scrollView使用autoLayout。由此引发了我一个疑问，能够通过修改containerView的高度约束来修改scrollView的contentSize么？
还是说scrollView的contentSize
在awakeFromNib的时候就定死了，只能通过手动设置重新改大小呢？
通过demo测试发现，这个想法是可行的，但是在重新设置了约束之后需要调用&lt;code&gt;[self.view layoutIfNeeded];&lt;/code&gt;这样scrollView才会重新计算contentSize。
还有个相似的方法&lt;code&gt;[self.view updateConstraints];&lt;/code&gt;这个方法不会立马更新scrollView的contentSize，而是在一定时间后更新，我猜测这个时间应该就是更新UI的动画时间。
为了防止计算出错还是建议都使用layoutIfNeeded方法。
&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;scrollview-2&quot;&gt;ScrollView的总结&lt;/h3&gt;
&lt;p&gt;关于scrollView目前想知道的就这些，这篇博客做个总结：使用scrollView最好是只添加一个UIView作为容器View，然后再在这个容器View里面设置你的布局。
这种方式很像Android的XML文件布局，只有一个LinearLayout作为容器。这样做的好处就是更改contentSize非常方便，直接修改容器View的高度约束，然后调用layoutIfNeeded方法就可。
切记要给容器View设置上下左右间距以及宽高.&lt;/p&gt;


    &lt;p&gt;&lt;a href=&quot;/ios/record/scrollview/&quot;&gt;关于ScrollView的学习&lt;/a&gt; was originally published by 陆 伟 at &lt;a href=&quot;&quot;&gt;Life is a Struggle&lt;/a&gt; on October 22, 2015.&lt;/p&gt;
  </content>
</entry>


<entry>
  <title type="html"><![CDATA[MBXPageViewController的两点优化修改]]></title>
 <link rel="alternate" type="text/html" href="/ios/structure/mbxpageviewcontroller/" />
  <id>/ios/structure/mbxpageviewcontroller</id>
  <published>2015-10-20T19:21:56+08:00</published>
  <updated>2015-10-20T19:21:56+08:00</updated>
  <author>
    <name>陆 伟</name>
    <uri></uri>
    <email>1071932819@qq.com</email>
  </author>
  <content type="html">
    &lt;h3 id=&quot;mbxpageviewcontroller&quot;&gt;MBXPageViewController是什么？&lt;/h3&gt;
&lt;figure&gt;
	&lt;img src=&quot;/images/IOS/structure/MBXPageViewController/scrollDelegateBefore.gif&quot; alt=&quot;项目实例&quot; /&gt;
	&lt;figcaption&gt;&lt;a href=&quot;https://www.9panart.com/html/passport/passport_login.html?ran=19406317709945142&quot;&gt;泛艺术客户端.&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;这里是&lt;a href=&quot;https://github.com/Moblox/MBXPageViewController&quot;&gt;原作者的主页&lt;/a&gt;，Moblox也是参照的其他作者的源代码改的，为了集成更多的样式。
这个控件是我一个同事集成到项目中来的，集成后UI那边添加了两个需求：1.点击title上面的按钮需要让当前页面滚动到顶部 2.title下面的tabIndicator需要跟页面同步滑动。
于是我不得不去研究了下MBXPageViewController的源码。&lt;/p&gt;

&lt;p&gt;MBXPageViewController是仿照RKSwipeBetweenViewControllers写的，通过源码可以看出并不是一个完成品，因为RKSwipeBetweenViewControllers是支持tabIndicator与页面同步滑动的。
所以第二个问题就简单了，把MBXPageViewController完成就可以了。&lt;/p&gt;

&lt;p&gt;首先我对比了MBXPageViewController和RKSwipeBetweenViewControllers的优缺点。虽然MBXPageViewController的watch和fork远低于RKSwipeBetweenViewControllers，
MBXPageViewController的使用还是远远比RKSwipeBetweenViewControllers简单清晰，而且能适应更多的特殊UI情况。&lt;/p&gt;

&lt;p&gt;使用MBXPageViewController.&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
MBXPageViewController *MBXPageController = [MBXPageViewController new];
MBXPageController.MBXDataSource = self;
MBXPageController.MBXDataDelegate = self;
[MBXPageController reloadPages];
&lt;/pre&gt;
&lt;p&gt;很简单易懂，有可能有人不理解，为什么没有看到addChildViewController或者addSubview之类的方法？其实这些都封装在了[MBXPageController reloadPages]方法里面
进去看源码就会发现：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
- (void)loadControllerAndView
{
    NSAssert([[self MBXDataSource] isKindOfClass:[UIViewController class]], @&quot;This needs to be implemented in a class that inherits from UIViewController&quot;);
    [(UIViewController *)[self MBXDataSource] addChildViewController:self];
    [[[self MBXDataSource] MBXPageContainer] addSubview:self.view];
}
&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;addChildViewController我的理解就是重新设置子controller的父controller，也就是层级关系，防止后面再Push或者Present新窗口的时候出错&lt;/li&gt;
&lt;li&gt;addSubview就更加直观了不需要多解释，没有这句话咱们就没有View可以显示了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意的是[[self MBXDataSource] MBXPageContainer]这个方法，他是MBXDataSource协议里必选的方法
说到这里就必须说说为什么我认为MBXPageViewController的使用远远比RKSwipeBetweenViewControllers简单清晰，就是因为两个协议：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
@protocol MBXPageControllerDataSource &amp;lt;NSObject&amp;gt;
@required
- (NSArray *)MBXPageButtons;
- (NSArray *)MBXPageControllers;
- (UIView *)MBXPageContainer;
@end

@protocol MBXPageControllerDataDelegate &amp;lt;NSObject&amp;gt;
@optional
- (void)MBXPageChangedToIndex:(NSInteger)index;
@end
&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;MBXPageButtons 就是标题栏上面的按钮，需要注意的是MBXPageViewController并不管按钮的显示，MBXPageViewController只负责帮我们绑定按钮的触摸事件，
    显示正确的对应的页面&lt;/li&gt;
&lt;li&gt;MBXPageControllers 这个就是咱们页面的数组了。&lt;/li&gt;
&lt;li&gt;MBXPageContainer 是页面的容器，只需要返回MBXPageViewController所在的UIViewController的container就行。&lt;/li&gt;
&lt;li&gt;MBXPageChangedToIndex 是一个提供给用户更新按钮状态的方法，当页面索引改变后就会触发这个方法，用户应该在这里跟新title
    上面按钮和tabIndicator的状态.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整个协议的完整实现大概应该是这个样子：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
#pragma mark - MBXPageViewController Data Source

- (NSArray *)MBXPageButtons
{
    return @[self.button1, self.button2, self.button3];
}

- (UIView *)MBXPageContainer
{
    return self.container;
}

- (NSArray *)MBXPageControllers
{
    // You can Load a VC directly from Storyboard
    UIStoryboard* mainStoryboard = [UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil];

    UIViewController *demo  = [mainStoryboard instantiateViewControllerWithIdentifier:@&quot;firstController&quot;];
    UIViewController *demo2  = [mainStoryboard instantiateViewControllerWithIdentifier:@&quot;secondController&quot;];

    // Or Load it from a xib file
    UIViewController *demo3 = [UIViewController new];
    demo3.view = [[[NSBundle mainBundle] loadNibNamed:@&quot;View&quot; owner:self options:nil] objectAtIndex:0];

    // Or create it programatically
    UIViewController *demo4 = [[UIViewController alloc] init];
    demo4.view.backgroundColor = [UIColor orangeColor];

    UILabel *fromLabel = [[UILabel alloc]initWithFrame:CGRectMake( (self.view.frame.size.width - 130)/2 , 40, 130, 40)];
    fromLabel.text = @&quot;Fourth Controller&quot;;

    [demo4.view addSubview:fromLabel];

    // The order matters.
    return @[demo,demo2, demo3];
}
&lt;/pre&gt;
&lt;p&gt;怎么样，是不是非常简单清晰。下面需要解决的就是我们UI提出的需求问题了，也很简单，修改绑定button的事件：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
- (void)controllerModeLogicForDestination:(NSInteger)destination
{
    __weak __typeof(&amp;amp;*self)weakSelf = self;
    NSInteger tempIndex = _currentPageIndex;
    // Check to see which way are you going (Left -&amp;gt; Right or Right -&amp;gt; Left)
    if (destination &amp;gt; tempIndex) {
        for (int i = (int)tempIndex+1; i&amp;lt;=destination; i++) {
            [self setPageControllerForIndex:i direction:UIPageViewControllerNavigationDirectionForward currentMBXViewController:weakSelf destionation:destination];
        }
    }

    // Right -&amp;gt; Left
    else if (destination &amp;lt; tempIndex) {
        for (int i = (int)tempIndex-1; i &amp;gt;= destination; i--) {
            [self setPageControllerForIndex:i direction:UIPageViewControllerNavigationDirectionReverse currentMBXViewController:weakSelf destionation:destination];
        }
    }else{
        [weakSelf updateCurrentPageIndex:tempIndex];
    }
}
&lt;/pre&gt;
&lt;p&gt;只加了一句[weakSelf updateCurrentPageIndex:tempIndex];然后我们可以自己在updateCurrentPageIndex方法里判断，如果当前索引跟传入的索引相同则当成点击事件来处理，否则则是页面切换事件，需要跟新button的状态，
这样我们就解决了第一个问题。第二个问题比较复杂，我到现在都还没完成搞清楚why，只知道要这么做。
我们先把MBXPageControllerDataDelegate协议拓展一下，添加两个方法：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
@protocol MBXPageControllerDataDelegate &amp;lt;NSObject&amp;gt;
@optional
- (void)MBXPageChangedToIndex:(NSInteger)index;
- (void)MBXPageSelectdViewOffset:(CGFloat)offset;
- (CGFloat)MBXPageTabIndicatorStartOffset:(NSInteger)tabIndex;
@end
&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;MBXPageTabIndicatorStartOffset返回tabIndex被选中时的tabIndicator的X坐标。别问我为什么要这么做，我也是一知半解。&lt;/li&gt;
&lt;li&gt;MBXPageSelectdViewOffset就是事实跟新tabIndicator的X坐标的方法，offset就是X的新坐标。这两个接口有了之后就需要判断在那里加了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过分析源码可以看到有个很诡异的事情：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
-  (void)syncScrollView
{
    for (UIView* view in _pageController.view.subviews){
        if([view isKindOfClass:[UIScrollView class]])
        {
            _pageScrollView = (UIScrollView *)view;
            _pageScrollView.delegate = self;
        }
    }
}
&lt;/pre&gt;
&lt;p&gt;_pageScrollView.delegate = self;可以整个代码里并没有实现ScrollDelegate的方法，我对比了一下RKSwipeBetweenViewControllers才发现原作者并没有copy这个delegate，原因可能是他的项目里当时不需要这个特性。
很显然我们需要实现这个ScrollDelegate，并在滑动过程中同步调用MBXPageSelectdViewOffset来跟新tabIndicator的X坐标：&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
#pragma mark - scroll view delegate
//It extracts the xcoordinate from the center point and instructs the selection bar to move accordingly
-(void)scrollViewDidScroll:(UIScrollView *)scrollView{
    if ([self MBXDataDelegate]
        &amp;amp;&amp;amp; [self.MBXDataDelegate respondsToSelector:@selector(MBXPageSelectdViewOffset:)]
        &amp;amp;&amp;amp; [self.MBXDataDelegate respondsToSelector:@selector(MBXPageTabIndicatorStartOffset:)]) {
//        CGFloat offsetPercent = scrollView.contentOffset.x / scrollView.contentSize.width;
//        [self.MBXDataDelegate MBXPageSelectdViewOffset:offsetPercent];
//        NSLog(@&quot;Scrolled percentage: %f   %f&quot;, scrollView.contentOffset.x,scrollView.contentSize.width);
        CGFloat xFromCenter = self.view.frame.size.width-scrollView.contentOffset.x; //%%% positive for right swipe, negative for left

        //%%% checks to see what page you are on and adjusts the xCoor accordingly.
        //i.e. if you&#39;re on the second page, it makes sure that the bar starts from the frame.origin.x of the
        //second tab instead of the beginning
        NSInteger xCoor = [self.MBXDataDelegate MBXPageTabIndicatorStartOffset:self.currentPageIndex];
        [self.MBXDataDelegate MBXPageSelectdViewOffset:(xCoor-xFromCenter/[self.viewControllerArray count])];;
    }
}
&lt;/pre&gt;

&lt;p&gt;必须得承认，如果没有看RKSwipeBetweenViewControllers我到死都不可能完成这个方法。了解pageController这个容器的都知道，这个容器为了节省内容，会在他认为合适的时候把看不到的子controller移除。
这可真是个要命的特性，我刚开始的想法理所当然的认为scrollView.contentOffset.x/scrollView.contentSize.width就是滚动的比例，然后根据这个比例来更新咱们的tabIndicator。可是当我
把scrollView.contentOffset.x和scrollView.contentSize.width打印出来后我傻眼了，简直混乱的不要不要的，完全不对头。之后在一段时间的探索后我猛然发现，原来RKSwipeBetweenViewControllers有
同步跟新tabIndicator这个特性。。。
下面是最后的效果图：&lt;/p&gt;
&lt;figure&gt;
	&lt;img src=&quot;/images/IOS/structure/MBXPageViewController/scrollDelegateAfter.gif&quot; alt=&quot;项目实例&quot; /&gt;
	&lt;figcaption&gt;&lt;a href=&quot;https://www.9panart.com/html/passport/passport_login.html?ran=19406317709945142&quot;&gt;泛艺术客户端.&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

    &lt;p&gt;&lt;a href=&quot;/ios/structure/mbxpageviewcontroller/&quot;&gt;MBXPageViewController的两点优化修改&lt;/a&gt; was originally published by 陆 伟 at &lt;a href=&quot;&quot;&gt;Life is a Struggle&lt;/a&gt; on October 20, 2015.&lt;/p&gt;
  </content>
</entry>


<entry>
  <title type="html"><![CDATA[Elixir on Phoenix]]></title>
 <link rel="alternate" type="text/html" href="/elixir/phoenix/elixir-on-phoenix/" />
  <id>/elixir/phoenix/elixir-on-phoenix</id>
  <published>2015-10-20T19:16:31+08:00</published>
  <updated>2015-10-20T19:16:31+08:00</updated>
  <author>
    <name>陆 伟</name>
    <uri></uri>
    <email>1071932819@qq.com</email>
  </author>
  <content type="html">
    &lt;h3 id=&quot;elixir-on-phoenix&quot;&gt;为什么要学习Elixir on Phoenix？&lt;/h3&gt;

&lt;figure&gt;
    
    &lt;a href=&quot;/images/elixir/phoenix/phoenix-vs-rails.png&quot;&gt;&lt;img src=&quot;/images/elixir/phoenix/phoenix-vs-rails.png&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;
    
    &lt;figcaption&gt;Elixir on Phoenix vs Ruby on Rails&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;这里有一篇&lt;a href=&quot;http://www.littlelines.com/blog/2014/07/08/elixir-vs-ruby-showdown-phoenix-vs-rails/&quot;&gt;帖子&lt;/a&gt;，对比了Ruby on Rails和Elixir on Phoenix。
我学过的服务器语言和框架不多，在学校的时候做过一段时间SSH框架，当时写的时候感觉挺屌的， 需要配置一大堆的Spring action，还有hybridization，从数据库里面取出来就是对象，很方便。
进了生命里第一家公司后，我接触到了Ruby on Rails。然后才发现SSH框架简直就是老爷爷玩的东西。(PS:不谈什么效率，小公司目标受众顶天了100万级别)
十分钟写好一个五脏俱全的服务器，简直是敏捷开发的大杀器啊。很可惜的是Ruby on Rails的效率确实不高，所以当我看到了跟它很像的Elixir on Phoenix的时候 ，
我顿时觉得Elixir on Phoenix这个框架必然会取代Ruby on Rails甚至其他一些老牌框架和语言。因为Elixir是基于Erlang写的，有点像Node-js，都是面向过程的语言。&lt;/p&gt;

&lt;p&gt;安装Elixir和Phoenix 步骤不赘述了 网上一搜一大堆.
程序员看世界，第一步，写一个Hello world程序。&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
mix phoenix.new hello_phoenix
&lt;/pre&gt;
&lt;p&gt;看起来跟Ruby on Rails一样一样的,需要注意的是，看它官网的说明，你需要先安装node-js，然后在提示&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
Fetch and install dependencies? [Yn]
&lt;/pre&gt;
&lt;p&gt;的时候，你必须输入Y，否则程序运行起来后会报错.
写到这里我发现我卡在了&lt;/p&gt;
&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
* running mix deps.get
&lt;/pre&gt;
&lt;p&gt;我以为是网络问题，Ctrl+C强制退出去，删了挂上VPN重新来一遍，然后还是卡在那儿不动。。。 草,什么鬼。无奈我换了一种姿势，首先运行&lt;/p&gt;

&lt;pre class=&quot;brush: cpp;auto-links: true;collapse: true;first-line: 1;gutter: true;html-script: true;light: true;ruler: false;smart-tabs: true;tab-size: 4;toolbar: true;&quot;&gt;
mix phoenix.new hello_phoenix
Fetch and install dependencies? [Yn] n
We are all set! Run your Phoenix application:
$ cd hello_world
$ mix deps.get
$ mix phoenix.server
&lt;/pre&gt;

&lt;p&gt;按照提示一步步做，然后成了。。。。。。心中十万个草泥马奔腾而过，劳资满心欢喜的想学习这个框架，结果一上来就给劳资出了这么个Bug，后面还玩得动么。。。&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/elixir/phoenix/elixir-on-phoenix/&quot;&gt;Elixir on Phoenix&lt;/a&gt; was originally published by 陆 伟 at &lt;a href=&quot;&quot;&gt;Life is a Struggle&lt;/a&gt; on October 20, 2015.&lt;/p&gt;
  </content>
</entry>

</feed>
